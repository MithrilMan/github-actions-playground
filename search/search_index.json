{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"test/","text":"test","title":"Test"},{"location":"bitcoin-shard/network/","text":"Network Protocol The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section. Peer Context Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. public class PeerContextFactory<TPeerContext> : IPeerContextFactory where TPeerContext : IPeerContext Accepting a connection Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface. ServerPeerConnectionGuardBase In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger; protected readonly ForgeConnectivitySettings settings; public ServerPeerConnectionGuardBase(ILogger logger, IOptions<ForgeConnectivitySettings> options) { this.logger = logger; settings = options.Value; } public ServerPeerConnectionGuardResult Check(IPeerContext peerContext) { string? denyReason = TryGetDenyReason(peerContext); if (!string.IsNullOrEmpty(denyReason)) { logger.LogDebug(\"Peer connection guard not passed: {denyReason}\", denyReason); return ServerPeerConnectionGuardResult.Deny(denyReason); } return ServerPeerConnectionGuardResult.Allow(); } internal abstract string? TryGetDenyReason(IPeerContext peerContext); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats; public MaxConnectionThresholdGuard(ILogger<MaxConnectionThresholdGuard> logger, IOptions<ForgeConnectivitySettings> settings, IConnectivityPeerStats serverPeerStats) : base(logger, settings) { _peerStats = serverPeerStats; } internal override string? TryGetDenyReason(IPeerContext peerContext) { if (_peerStats.ConnectedInboundPeersCount >= settings.MaxInboundConnections) { return \"Inbound connection refused: max connection threshold reached.\"; } return null; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. \ud83d\udcdd NOTE These classes have to be registered as singleton and therefor must be stateless. Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization.","title":"Network"},{"location":"bitcoin-shard/network/#network-protocol","text":"The Bitcoin network protocol is a TCP protocol that serializes messages starting from a special 4 bytes constant data called Magic bytes , followed by 12 bytes representing the command name , 4 bytes representing the payload size and 4 bytes with the checksum of the payload. More specific information about bitcoin protocol can be found here. Mithril Shards implements a low level stack of interfaces and implementations that allow to focus on the application logic instead on low level details. A default implementation uses Bedrock Framework to leverage the low level communication between peers and this is what's used in the Bitcoin shard to provide P2P connectivity. A typical Bitcoin full node (henceforth called FN ) is able to connect to other nodes and accept incoming connections. Before two peers can exchange information, they have to perform an handshake to prove that they can understand each other (more details on the the bitcoin network protocol can be found on this bitcoin developer resource ). Before being able to handshake, whenever a connection has been established between two peers the FN stores some metadata about the remote peer. This data is stored into a class that implements IPeerContext interface and its implementation represents our next section.","title":"Network Protocol"},{"location":"bitcoin-shard/network/#peer-context","text":"Default Mithril Shards implementation uses PeerContext class to store, among other things, information like peer unique identification, direction (inbound/outbound) remote and local endpoints, user agent identification, negotiated protocol version and other attachable properties leveraging the .Net IFeatureCollection interface. Bitcoin needs some additional information and some of the properties that are ubiquitous needed among all optional Bitcoin features (shards) like wallet, APIs, indexer, etc... have been defined directly into BitcoinPeerContext that extends the default PeerContext . Some of the additional properties are Permissions (that may change the FN behavior based on its set) and TimeOffset, that's an important aspect for the consensus logic. Another important property exposed by peer context is the ConnectionCancellationTokenSource property, that's a CancellationTokenSource that can be used to trigger the disconnection from a peer. It's internally used to know when the connection has been closed, to stop the execution of async methods that rely on an active connection to a remote peer. As per IPeerContext interface, ConnectionCancellationTokenSource can only be read so it's important that custom implementation of IPeerContext don't change it's value out of constructor. This property is actively used within message processors (more about it in a later section). The cancellation of ConnectionCancellationTokenSource shouldn't be canceled directly, to force a peer disconnection an event of type PeerDisconnectionRequired has to be published on the event bus, but for simplicity BitcoinPeerContext implements a Disconnect method that does that. So anytime you have a need to disconnect a peer, just call thePeerContext.Disconnect(\"My Disconnection reason!\") . You can find already usage of it in message processor classes. The peer context creation is handled by the core Mithril Shard network implementation and since it can't know about the BitcoinPeerContext properties, it relies on a peer context factory, in this case we are talking about BitcoinPeerContextFactory class. It leverages the generic class PeerContextFactory<> and its implementation is bare bone, no need to override anything. public class PeerContextFactory<TPeerContext> : IPeerContextFactory where TPeerContext : IPeerContext","title":"Peer Context"},{"location":"bitcoin-shard/network/#accepting-a-connection","text":"Once the peer context has been created, a sanity check is performed to see if the two peers can connect to each other before trying to handshake and the behavior is very similar to both inbound and outbound connections. The only difference is that actually for outgoing connection the check is done before trying to connect but very likely it would be done as per incoming connection soon. What happens when an incoming connection has been accepted is that the connection has to pass all registered (in the DI containers) implementations of IServerPeerConnectionGuard interface.","title":"Accepting a connection"},{"location":"bitcoin-shard/network/#serverpeerconnectionguardbase","text":"In Bitcoin shard all guard rules are extending ServerPeerConnectionGuardBase implementation that's a simple class: public abstract class ServerPeerConnectionGuardBase : IServerPeerConnectionGuard { protected readonly ILogger logger; protected readonly ForgeConnectivitySettings settings; public ServerPeerConnectionGuardBase(ILogger logger, IOptions<ForgeConnectivitySettings> options) { this.logger = logger; settings = options.Value; } public ServerPeerConnectionGuardResult Check(IPeerContext peerContext) { string? denyReason = TryGetDenyReason(peerContext); if (!string.IsNullOrEmpty(denyReason)) { logger.LogDebug(\"Peer connection guard not passed: {denyReason}\", denyReason); return ServerPeerConnectionGuardResult.Deny(denyReason); } return ServerPeerConnectionGuardResult.Allow(); } internal abstract string? TryGetDenyReason(IPeerContext peerContext); } This class implements the plumbing code required to run (and log in case of rule check not passed) the guard rule, so a guard rule implementation has just to focus on its guarding logic. A simple example is the MaxConnectionThresholdGuard rule that ensure that an incoming transaction doesn't exceed the maximum allowed number of inbound connections: public class MaxConnectionThresholdGuard : ServerPeerConnectionGuardBase { readonly IConnectivityPeerStats _peerStats; public MaxConnectionThresholdGuard(ILogger<MaxConnectionThresholdGuard> logger, IOptions<ForgeConnectivitySettings> settings, IConnectivityPeerStats serverPeerStats) : base(logger, settings) { _peerStats = serverPeerStats; } internal override string? TryGetDenyReason(IPeerContext peerContext) { if (_peerStats.ConnectedInboundPeersCount >= settings.MaxInboundConnections) { return \"Inbound connection refused: max connection threshold reached.\"; } return null; } } In order to be used during connection check, these guard classes have to be registered in the DI container. MaxConnectionThresholdGuard for example is registered into the extension that register the bitcoin shard by using services.AddSingleton<IServerPeerConnectionGuard, InitialBlockDownloadStateGuard>() This allow the flexibility of having custom guard rule simply by implementing a rule and register in the DI container, any required service will be injected automatically; of course if it relies on a custom service not already available in my implementation, that service has to be registered too. \ud83d\udcdd NOTE These classes have to be registered as singleton and therefor must be stateless. Network protocol is implemented through the serialization of classes which implement INetworkMessage interface and are decorated with NetworkMessageAttribute that works in synergy with an implementation of INetworkMessageSerializer to implement network serialization.","title":"ServerPeerConnectionGuardBase"},{"location":"bitcoin-shard/readme/","text":"Premise This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project but I don't pretend to have documentation always in sync with latest changes because it's a huge effort and I agree at some extents that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct and please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section . Project Overview Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, WEB Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A WEB Api infrastructure allow to create WEB Api endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.","title":"Readme"},{"location":"bitcoin-shard/readme/#premise","text":"This folder contains technical documentation that helps to understand the choices behind the implementation and design of current project. Personally I'm not a fan of bitcoin core code base: even if it improved since early days, it's confusing, it lacks of an homogeneous design and architecture and suffers from old bad choices and above all lacks of proper technical documentation, following the mantra \"source code is the documentation\". To be clear, I don't blame who contributes on bitcoin core, I'm just stating objective facts and I hope to fix some of these issues with my project but I don't pretend to have documentation always in sync with latest changes because it's a huge effort and I agree at some extents that source code is the final judge and I encourage you to dig into it if you want to go deeper in implementation details or verify that an information written here is correct and please, if you find any issue about documentation, feel free to open an issue and I'll be happy to fix it (even a PR with your corrections can be valuable!). To me a proper documentation doesn't have to explain the source code (source code should be as much readable as possible) but it should give insights about the process that leads toward specific implementations and have indications about good practice to work within the built library. Beside this premise, I'm writing this documentation as if I were the target, in order to have a maintainable and easy to follow repository and of course be able to give good understanding about how to extend this project further with custom features (shards) to people that may be interested. Nevertheless I would be happy to know that it could be useful to someone who may find it interesting and help in understanding why an approach has been chosen over another! Also if you have question or want to discuss about technical details, you can use the repository Discussion section .","title":"Premise"},{"location":"bitcoin-shard/readme/#project-overview","text":"Bitcoin Mithril Shard has been built on top of Mithril Shards framework. Mithril Shards goal is to be a framework and toolkit to build modular and distributed/P2P applications using .Net 5 stack, focusing both on good design, good practices and performance. Core functionalities can be glued togheter to compose the needed application, ranging from a P2P network layer, WEB Api layer, Diagnostic tools, cross platform UI based on blazor, distributed eventing using SignalR, MQ brokers like RabbitMq or any kind of other useful libraries. Thanks to its design, anyone can build it's own Shard to create other features that can be used by Mithril Shards community. More details about Mithril Shards can be found on the main documentation (TODO). Bitcoin shard is a very good example about how to build a fully functional full node for bitcoin, leveraging all the juicy features that Mithril Shards exposes. Network layer is implemented by leveraging Bedrock Framework for the TCP implementation using both Client and Server connections. Data is serialized thanks to an well defined set of interfaces and classes that allows to implement an easy to read and maintain code. Incoming messages are dispatched to \"Message Processors\" that allow to handle the application logic following a good practice of separation of concerns. Meaningful events are dispatched using a message bus implementation that can reach any component in any application layer. A WEB Api infrastructure allow to create WEB Api endpoint easily and each feature can have its set of API published on different document specifications. Swagger is used as a UI to expose these API documents and allows to execute these APIs straight from that interface. For development/debugging purpose, a Shard inject some useful endpoint to inspect internal details of the running application. Logging is done using structured logging, makes use of Serilog to persist them and a configuration example shows how to use Seq to have a very good UI to view logs, filter them, etc... Blazor is used to implement a cross platform UI as a companion for the full node.","title":"Project Overview"}]}